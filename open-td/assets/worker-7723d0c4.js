var st=Object.defineProperty;var it=(H,R,m)=>R in H?st(H,R,{enumerable:!0,configurable:!0,writable:!0,value:m}):H[R]=m;var v=(H,R,m)=>(it(H,typeof R!="symbol"?R+"":R,m),m);(function(){"use strict";const H=e=>e.constructor.scale;function R(e){return e?"getTile"in e:!1}var m=(e=>(e[e.Unknown=0]="Unknown",e[e.Player=1]="Player",e[e.Enemy=2]="Enemy",e))(m||{}),F=(e=>(e[e.None=0]="None",e[e.Tower=1]="Tower",e[e.Slime=2]="Slime",e[e.Base=3]="Base",e[e.Bullet=4]="Bullet",e[e.Wall=5]="Wall",e[e.Mortar=6]="Mortar",e[e.Flamethrower=7]="Flamethrower",e[e.Flame=8]="Flame",e[e.Railgun=9]="Railgun",e[e.Rail=10]="Rail",e[e.ElectricFence=11]="ElectricFence",e[e.Fence=12]="Fence",e[e.Freezer=13]="Freezer",e[e.Tree=14]="Tree",e[e.Rock=15]="Rock",e[e.Radar=16]="Radar",e[e.PowerPlant=17]="PowerPlant",e[e.Blueprint=18]="Blueprint",e[e.Shockwave=19]="Shockwave",e[e.Armory=20]="Armory",e[e.Market=21]="Market",e[e.SpeedBeacon=22]="SpeedBeacon",e[e.Runner=23]="Runner",e[e.DamageBeacon=24]="DamageBeacon",e[e.Laser=25]="Laser",e[e.LaserBeam=26]="LaserBeam",e[e.Flier=27]="Flier",e[e.Tank=28]="Tank",e[e.Rocket=29]="Rocket",e[e.WavePoint=30]="WavePoint",e[e.Barracks=31]="Barracks",e[e.Tesla=32]="Tesla",e[e.Spark=33]="Spark",e[e.Excavator=34]="Excavator",e[e.Convert=35]="Convert",e[e.Terraform=36]="Terraform",e[e.EmergencyRecharge=37]="EmergencyRecharge",e[e.EmergencyRepair=38]="EmergencyRepair",e))(F||{});[...new Set([3,16,17,20,21,31])];var W=(e=>(e[e.Undiscovered=0]="Undiscovered",e[e.Pending=1]="Pending",e[e.Discovered=2]="Discovered",e))(W||{}),u=(e=>(e[e.Void=0]="Void",e[e.Grass=1]="Grass",e[e.Stone=2]="Stone",e[e.Water=3]="Water",e[e.Obstructed=4]="Obstructed",e[e.Wall=5]="Wall",e[e.Spore=6]="Spore",e[e.ElectricFence=7]="ElectricFence",e[e.Fence=8]="Fence",e[e.Freezer=9]="Freezer",e[e.Bridge=10]="Bridge",e[e.Dirt=11]="Dirt",e[e.Snow=12]="Snow",e[e.Sand=13]="Sand",e[e.Ice=14]="Ice",e[e.PlayerBuilding=15]="PlayerBuilding",e[e.Tree=16]="Tree",e[e.Rock=17]="Rock",e[e.Base=18]="Base",e))(u||{});const $=new Set([1,2,11,13,12]);[...new Set([...$,3,14,10,16,17])];const q={[F.Tower]:4,[F.Wall]:5,[F.Mortar]:4,[F.Flamethrower]:4,[F.Railgun]:4,[F.ElectricFence]:7,[F.Fence]:8,[F.Freezer]:9,[F.Radar]:18,[F.PowerPlant]:18,[F.Tree]:16,[F.Rock]:17,[F.Armory]:18,[F.Base]:18,[F.Market]:18,[F.SpeedBeacon]:4,[F.DamageBeacon]:4,[F.Laser]:4,[F.Barracks]:18,[F.Tesla]:4};class z{constructor(t,s,i=u.Void){v(this,"staticEntity",null);v(this,"hash");v(this,"actualType");v(this,"towers",[]);v(this,"linkedAgents");v(this,"discoveryStatus",W.Undiscovered);this.x=t,this.y=s,this.type=i,this.hash=`[${this.x}, ${this.y}]`,this.actualType=i}serialize(){return{x:this.x,y:this.y,type:this.type}}getX(){return this.x}getY(){return this.y}getBaseType(){return this.type}getType(){return this.actualType}getStaticEntity(){return this.staticEntity}hasStaticEntity(){return this.staticEntity!==null}setStaticEntity(t){if(this.staticEntity!==null)throw new Error("A tile can only have 1 static entity.");const s=t.getAgent();R(s)&&s.getTile().getHash()===this.getHash()&&(s.updateTile(this),this.linkedAgents&&s.updateLinkedAgents&&s.updateLinkedAgents(this.linkedAgents)),this.staticEntity=t,this.actualType=q[t.getAgent().getType()]||this.type}clearStaticEntity(){this.staticEntity=null,this.actualType=this.type}isStaticEntityRoot(){var t;return((t=this.staticEntity)==null?void 0:t.getAgent().getTile())===this}addTower(t){this.towers.includes(t)||this.towers.push(t)}setDiscoveryStatus(t){this.discoveryStatus=t}isDiscovered(){return this.discoveryStatus===W.Discovered}getDiscoveryStatus(){return this.discoveryStatus}isCoveredByTower(){return this.isDiscovered()&&this.towers.length>0}removeTower(t){this.towers.splice(this.towers.indexOf(t),1)}getAvailableTowers(){return this.towers.filter(t=>t.getCooldown()<=0)}getTowers(){return this.towers}addLinkedAgent(t){var i;this.linkedAgents||(this.linkedAgents=new Set),this.linkedAgents.add(t);const s=(i=this.staticEntity)==null?void 0:i.getAgent();s&&s.updateLinkedAgents&&s.updateLinkedAgents(this.linkedAgents)}removeLinkedAgent(t){var i;if(!this.linkedAgents)return;this.linkedAgents.delete(t);const s=(i=this.staticEntity)==null?void 0:i.getAgent();R(s)&&s.updateLinkedAgents&&s.updateLinkedAgents(this.linkedAgents)}getLinkedAgents(){return this.linkedAgents}getHash(){return this.hash}sync(t){this.towers=t.towers,this.discoveryStatus=t.discoveryStatus}}var X=(e=>(e[e.StatUpdate=0]="StatUpdate",e[e.SurfaceChange=1]="SurfaceChange",e[e.BlackOut=2]="BlackOut",e[e.OpenBuildMenu=3]="OpenBuildMenu",e[e.CloseBuildMenu=4]="CloseBuildMenu",e[e.SelectPlaceable=5]="SelectPlaceable",e[e.ToggleShowCoverage=6]="ToggleShowCoverage",e[e.StartWave=7]="StartWave",e[e.EndWave=8]="EndWave",e[e.Unlock=9]="Unlock",e[e.Discover=10]="Discover",e[e.Spawn=11]="Spawn",e[e.Buy=12]="Buy",e[e.Sell=13]="Sell",e[e.HitBase=14]="HitBase",e[e.Lose=15]="Lose",e))(X||{});const N=class{constructor(){v(this,"eventHandlers");N.instance=this,this.eventHandlers=new Map}addEventListener(t,s){return this.eventHandlers.has(t)?this.eventHandlers.get(t).add(s):this.eventHandlers.set(t,new Set([s])),()=>this.removeEventListener(t,s)}addEventListeners(t,s){const i=t.map(r=>this.addEventListener(r,s));return()=>i.forEach(r=>r())}removeEventListener(t,s){var i;(i=this.eventHandlers.get(t))==null||i.delete(s)}triggerEvent(t,...s){var i;(i=this.eventHandlers.get(t))==null||i.forEach(r=>r(...s))}static get Instance(){return this.instance}};let O=N;v(O,"instance");function Y(e){return"getCooldown"in e}const J=e=>e.constructor.range;class K{constructor(t){v(this,"map");v(this,"entities",[]);v(this,"deletedEntities",[]);v(this,"staticEntities",[]);v(this,"entitiesMap",new Map);v(this,"towers",new Set);v(this,"width");v(this,"height");v(this,"dirty",!1);v(this,"changedTiles",new Set);v(this,"addedAgents",new Set);v(this,"removedAgents",new Set);this.width=t.width,this.height=t.height;const s="buffer"in t?t.buffer:t.generate;this.initialize(s??((i,r)=>new z(i,r)))}serialize(){const t=new Uint8Array(this.map.length*3);for(let s=0;s<this.map.length;s++){const i=this.map[s],r=s*3;t[r]=i.getX(),t[r+1]=i.getY(),t[r+2]=i.getType()}return{width:this.width,height:this.height,buffer:t}}initialize(t){if(this.map=new Array(this.width*this.height),t instanceof Uint8Array)for(let s=0;s<this.map.length;s++){const i=s*3;this.map[s]=new z(t[i],t[i+1],t[i+2])}else for(let s=0;s<this.height;s++)for(let i=0;i<this.width;i++)this.map[s*this.width+i]=t(i,s);this.entities=[],this.deletedEntities=[],this.staticEntities=[],this.entitiesMap.clear(),Object.values(m).filter(s=>typeof s!="string").forEach(s=>this.entitiesMap.set(s,new Set))}getTile(t,s,i=!1){return t>=this.width||t<0||s>=this.height||s<0?i?this.getTile(Math.max(Math.min(t,this.width-1),0),Math.max(Math.min(s,this.height-1),0)):void 0:this.map[s*this.width+t]}getEntityTiles(t,s,i){let r;if(s)r=t;else{const h=t;r=h.getTile().getX(),s=h.getTile().getY(),i=H(h)}switch(i){case 1:return[this.map[s*this.width+r]];case 2:return[this.map[s*this.width+r],this.map[s*this.width+r+1],this.map[(s+1)*this.width+r],this.map[(s+1)*this.width+r+1]];default:throw new Error("Unsupported agent scale!")}}getAdjacentTiles(t,s=1){return[[1,0],[-1,0],[0,1],[0,-1]].map(([r,h])=>this.getTile(t.getX()+r*s,t.getY()+h*s)).filter(r=>!!r)}setTile(t){this.setTileInternal(t)}setTiles(t){t.map(s=>this.setTileInternal(s))}setTileInternal(t){this.dirty=!0;const s=this.map[t.getY()*this.width+t.getX()];return s.hasStaticEntity()&&!t.hasStaticEntity()?t.setStaticEntity(s.getStaticEntity()):s.hasStaticEntity()&&this.despawnStatic(s.getStaticEntity().getAgent()),t.sync(s),this.map[t.getY()*this.width+t.getX()]=t,this.changedTiles.add(s),s}processChangedTiles(){!this.changedTiles.size||(O.Instance.triggerEvent(X.SurfaceChange,{affectedTiles:this.changedTiles,addedStaticAgents:this.addedAgents,removedStaticAgents:this.removedAgents}),this.changedTiles.clear(),this.addedAgents.clear(),this.removedAgents.clear())}getRow(t){const s=t*this.width;return this.map.slice(s,s+this.width)}getColumn(t){const s=new Array(this.height);for(let i=0;i<this.height;i++)s[i]=this.getTile(t,i);return s}getWidth(){return this.width}getHeight(){return this.height}forLine(t,s,i,r,h,d){const l=(d==null?void 0:d.scale)??1;t=Math.floor(t/l)*l,s=Math.floor(s/l)*l,i=Math.floor(i/l)*l,r=Math.floor(r/l)*l;const g=Math.atan2(r-s,i-t);return this.forRay(t,s,g,(S,f)=>!(h(S,f)===!1)&&!(S.getX()===i&&S.getY()===r),d)}forRay(t,s,i,r,h){const d=(h==null?void 0:h.connected)??!1,l=(h==null?void 0:h.scale)??1,g=Math.cos(i),S=Math.sin(i),f=Math.abs(g)+Math.abs(S);let k=Math.abs(g/f),A=Math.abs(S/f),p=(1+(k>A?A/k:k/A))*l;k*=p*Math.sign(g),A*=p*Math.sign(S);let I,x,B=0;for(;;){let n=!1;const o=Math.round(t/l)*l;let c=Math.round(s/l)*l;d&&I!==void 0&&Math.round(I/l)*l!==o&&Math.round(x/l)*l!==c&&(c=Math.round(x),n=!0);const a=this.getTile(o,c);if(!a||!r(a,B))break;n||(t+=k,s+=A),I=o,x=c,B++}}forRect(t,s,i,r,h,d){const l=(d==null?void 0:d.scale)??1;t=Math.floor(t/l)*l,s=Math.floor(s/l)*l,i=Math.floor(i/l)*l,r=Math.floor(r/l)*l;const g=(f,k)=>{const A=this.getTile(f,k);A&&h(A)},S=f=>{if(i>t)for(let k=t;k<=i;k+=l)g(k,f);else for(let k=t;k>=i;k-=l)g(k,f)};if(r>s)for(let f=s;f<=r;f+=l)S(f);else for(let f=s;f>=r;f-=l)S(f)}forCircle(t,s,i,r,h){const d=(h==null?void 0:h.edgeOnly)??!1,l=(h==null?void 0:h.scale)??1;t=Math.floor(t/l),s=Math.floor(s/l);let g=i/2;const S=g*g,f=(g-1)*(g-1),k=(A,p,I=0)=>{const x=A+I,B=p+I,n=x*x+B*B;if(n<S&&!(d&&n<f)){const o=this.getTile((t+A)*l,(s+p)*l,d);o&&r(o)}};if(i%2===0)for(let A=-g;A<g;A+=1)for(let p=-g;p<g;p+=1)k(p,A,.5);else{g=g|0;for(let A=-g;A<g+1;A+=1)for(let p=-g;p<g+1;p+=1)k(p,A)}}spawn(t){this.entities.push(t.entity),this.entitiesMap.get(t.category).add(t.entity),t.spawn&&t.spawn()}spawnStatic(t){this.getEntityTiles(t).forEach(i=>{i.setStaticEntity(t.entity),this.changedTiles.add(i)}),this.addedAgents.add(t),this.spawn(t),this.dirty=!0,Y(t)&&J(t)>1&&this.towers.add(t)}despawn(t){const s=this.entities.indexOf(t.entity);s>=0&&this.entities.splice(s,1);const i=this.entitiesMap.get(t.category).delete(t.entity);return this.deletedEntities.push(t.entity),t.despawn&&t.despawn(),i}despawnStatic(t){this.getEntityTiles(t).forEach(i=>{i.clearStaticEntity(),this.changedTiles.add(i)}),this.removedAgents.add(t),this.despawn(t),this.dirty=!0,Y(t)&&this.towers.delete(t)}getEntities(){return this.entities}getEntitiesForCategory(t){return this.entitiesMap.get(t)}getDeletedEntities(){return this.deletedEntities}getStaticEntities(){return this.staticEntities}getTowers(){return this.towers}markPristine(){this.dirty=!1,this.deletedEntities=[]}forceRerender(){this.dirty=!0}isDirty(){return this.dirty}}var Q=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Z(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var V={exports:{}},j={exports:{}};(function(e,t){(function(){var s,i,r,h,d,l,g,S,f,k,A,p,I,x,B;r=Math.floor,k=Math.min,i=function(n,o){return n<o?-1:n>o?1:0},f=function(n,o,c,a,M){var w;if(c==null&&(c=0),M==null&&(M=i),c<0)throw new Error("lo must be non-negative");for(a==null&&(a=n.length);c<a;)w=r((c+a)/2),M(o,n[w])<0?a=w:c=w+1;return[].splice.apply(n,[c,c-c].concat(o)),o},l=function(n,o,c){return c==null&&(c=i),n.push(o),x(n,0,n.length-1,c)},d=function(n,o){var c,a;return o==null&&(o=i),c=n.pop(),n.length?(a=n[0],n[0]=c,B(n,0,o)):a=c,a},S=function(n,o,c){var a;return c==null&&(c=i),a=n[0],n[0]=o,B(n,0,c),a},g=function(n,o,c){var a;return c==null&&(c=i),n.length&&c(n[0],o)<0&&(a=[n[0],o],o=a[0],n[0]=a[1],B(n,0,c)),o},h=function(n,o){var c,a,M,w,C,L;for(o==null&&(o=i),w=function(){L=[];for(var b=0,D=r(n.length/2);0<=D?b<D:b>D;0<=D?b++:b--)L.push(b);return L}.apply(this).reverse(),C=[],a=0,M=w.length;a<M;a++)c=w[a],C.push(B(n,c,o));return C},I=function(n,o,c){var a;if(c==null&&(c=i),a=n.indexOf(o),a!==-1)return x(n,0,a,c),B(n,a,c)},A=function(n,o,c){var a,M,w,C,L;if(c==null&&(c=i),M=n.slice(0,o),!M.length)return M;for(h(M,c),L=n.slice(o),w=0,C=L.length;w<C;w++)a=L[w],g(M,a,c);return M.sort(c).reverse()},p=function(n,o,c){var a,M,w,C,L,b,D,_,U;if(c==null&&(c=i),o*10<=n.length){if(w=n.slice(0,o).sort(c),!w.length)return w;for(M=w[w.length-1],D=n.slice(o),C=0,b=D.length;C<b;C++)a=D[C],c(a,M)<0&&(f(w,a,0,null,c),w.pop(),M=w[w.length-1]);return w}for(h(n,c),U=[],L=0,_=k(o,n.length);0<=_?L<_:L>_;0<=_?++L:--L)U.push(d(n,c));return U},x=function(n,o,c,a){var M,w,C;for(a==null&&(a=i),M=n[c];c>o;){if(C=c-1>>1,w=n[C],a(M,w)<0){n[c]=w,c=C;continue}break}return n[c]=M},B=function(n,o,c){var a,M,w,C,L;for(c==null&&(c=i),M=n.length,L=o,w=n[o],a=2*o+1;a<M;)C=a+1,C<M&&!(c(n[a],n[C])<0)&&(a=C),n[o]=n[a],o=a,a=2*o+1;return n[o]=w,x(n,L,o,c)},s=function(){n.push=l,n.pop=d,n.replace=S,n.pushpop=g,n.heapify=h,n.updateItem=I,n.nlargest=A,n.nsmallest=p;function n(o){this.cmp=o??i,this.nodes=[]}return n.prototype.push=function(o){return l(this.nodes,o,this.cmp)},n.prototype.pop=function(){return d(this.nodes,this.cmp)},n.prototype.peek=function(){return this.nodes[0]},n.prototype.contains=function(o){return this.nodes.indexOf(o)!==-1},n.prototype.replace=function(o){return S(this.nodes,o,this.cmp)},n.prototype.pushpop=function(o){return g(this.nodes,o,this.cmp)},n.prototype.heapify=function(){return h(this.nodes,this.cmp)},n.prototype.updateItem=function(o){return I(this.nodes,o,this.cmp)},n.prototype.clear=function(){return this.nodes=[]},n.prototype.empty=function(){return this.nodes.length===0},n.prototype.size=function(){return this.nodes.length},n.prototype.clone=function(){var o;return o=new n,o.nodes=this.nodes.slice(0),o},n.prototype.toArray=function(){return this.nodes.slice(0)},n.prototype.insert=n.prototype.push,n.prototype.top=n.prototype.peek,n.prototype.front=n.prototype.peek,n.prototype.has=n.prototype.contains,n.prototype.copy=n.prototype.clone,n}(),function(n,o){return e.exports=o()}(this,function(){return s})}).call(Q)})(j),function(e){e.exports=j.exports}(V);var E=Z(V.exports);class P{constructor(t,s,i,r,h,d=[]){v(this,"index",0);v(this,"sectionIndex",0);v(this,"tileSet");this.pathfinder=t,this.tiles=s,this.sections=i,this.speed=r,this.costs=h,this.checkpoints=d,this.tileSet=new Set(s)}performStep(t,s){const i=this.index%1,r=this.index|0,h=this.tiles[r],d=this.speed*s/(this.costs[r]??1);let l=this.index+d|0;r===l&&l++,l>=this.tiles.length-1&&(l=this.tiles.length-1);const g=this.tiles[l];for(;this.checkpoints.length>0;){const f=this.checkpoints[0];if(f&&l>=f.index)if(f.isCleared(this.tiles,t))this.checkpoints.shift();else return this.index=f.index-1,{from:this.tiles[this.index],to:g,step:0};else break}const S=this.costs[l]??1;for(this.index=Math.min(this.index+this.speed*s/S,this.tiles.length-1);this.index>this.sections[this.sectionIndex].to;)this.sectionIndex++;return{from:h,to:g,step:i}}getFuturePosition(t){let s=this.index,i=this.sectionIndex;for(;t>0;){const r=this.sections[i],h=r.to-s,d=h/this.speed*r.cost;if(t>d?(s+=h,i++,t-=d):(s+=h*t/d,t=0),s>=this.tiles.length-1)return this.tiles.length-1}return s}fastForward(t){let s=this.checkpoints[0];for(let i=(this.index|0)+1;i<this.tiles.length;i++){if(s&&i>=s.index)if(s.isCleared(this.tiles,t))this.checkpoints.shift(),s=this.checkpoints[0];else break;if(this.getTile(i).isDiscovered())break;this.index=i}}clone(){return new P(this.pathfinder,this.tiles,this.sections,this.speed,this.costs,[...this.checkpoints])}slice(t=0,s=Number.MAX_VALUE){const i=this.tiles.slice(t,s),r=this.costs.slice(t,s),h=P.calculateSections(i,r),d=this.checkpoints.filter(l=>l.index>=t&&l.index<s);return new P(this.pathfinder,i,h,this.speed,r,d)}setIndex(t){this.index=Math.max(Math.min(t,this.tiles.length-1),0),this.sectionIndex=this.sections.findIndex(({from:s,to:i})=>this.index>=s&&this.index<i)}getIndex(){return this.index}getTile(t=this.index){return this.tiles[t|0]}getTiles(){return this.tiles}getLength(){return this.tiles.length}getCoordinates(t=this.index){if(t>=this.tiles.length-1){const h=this.tiles[this.tiles.length-1];return{x:h.getX(),y:h.getY()}}const s=t%1,i=this.tiles[t|0],r=this.tiles[(t|0)+1];return{x:(r.getX()-i.getX())*s+i.getX(),y:(r.getY()-i.getY())*s+i.getY()}}getSpeed(){return this.speed}setSpeed(t){this.speed=t}isDone(){return this.index===this.tiles.length-1}isPaused(t){if(this.isDone())return!0;const s=this.getNextCheckpoint();return s&&s.index===this.index+1&&!s.isCleared(this.tiles,t)}getNextCheckpoint(){return this.checkpoints[0]||null}getCheckpoints(){return this.checkpoints}setCheckpoints(t){this.checkpoints=t}getCurrentTile(){return this.tiles[this.index|0]}recompute(){const t=this.pathfinder.getSurface();let s;for(let i=0;i<this.tiles.length;i++){const r=this.tiles[i],h=t.getTile(r.getX(),r.getY());this.tiles[i]=h,this.costs[i]=this.pathfinder.getCost(h,s)??1,s=h,r!==h&&(this.tileSet.delete(r),this.tileSet.add(h))}this.sections=P.calculateSections(this.tiles,this.costs)}isAffectedByTiles(t){for(let s of t)if(this.tileSet.has(s))return!0;return!1}static calculateSections(t,s){return t.reduce((i,r,h)=>{const d=i[i.length-1],l=s[h];return d?(d.cost===l?d.to++:i.push({from:h,to:h+1,cost:l}),i):[{from:h,to:h+1,cost:l}]},[])}static fromTiles(t,s,i=1){const r=new P(t,s,[],i,[]);return r.recompute(),r}static fromMapAndCosts(t,s,i,r,h=1){let d=i;const l=[d];for(;d!==s;)d=r.get(d.getHash()),l.push(d);return this.fromTiles(t,l.reverse(),h)}}const G={[u.Grass]:3,[u.Water]:20,[u.Stone]:4,[u.Wall]:3,[u.Spore]:2,[u.ElectricFence]:5,[u.Fence]:20,[u.Freezer]:6,[u.Obstructed]:3,[u.Bridge]:5,[u.Dirt]:2.5,[u.Sand]:3.5,[u.Snow]:3.5,[u.Ice]:10,[u.PlayerBuilding]:3,[u.Tree]:5,[u.Rock]:5,[u.Base]:Number.EPSILON},T={[u.Fence]:5,[u.ElectricFence]:40,[u.Wall]:500,[u.Freezer]:.5,[u.Obstructed]:500,[u.PlayerBuilding]:-10};u.Grass+"",u.Water+"",u.Stone+"",u.Wall+"",u.Spore+"",u.ElectricFence+"",u.Fence+"",u.Freezer+"",u.Obstructed+"",u.Bridge+"",u.Dirt+"",u.Sand+"",u.Snow+"",u.Ice+"",u.PlayerBuilding+"",u.Tree+"",u.Rock+"",u.Base+"",Number.EPSILON,u.Fence+"",u.ElectricFence+"",u.Wall+"",u.Tree+"",u.Rock+"",u.Freezer+"",u.Obstructed+"",u.PlayerBuilding+"";const y=[[0,-1],[-1,0],[1,0],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]],tt=150;class et{constructor(t,s=T,i=G){this.surface=t,this.costMultipliers=s,this.costs=i}getPath(t,s,i){const r=i??(p=>this.costMultipliers[p.getType()]??1),h=new Set,l=(this.costs[t.getType()]??1)*r(t),g=new Map;g.set(t.getHash(),l);const S=new Map;S.set(t.getHash(),l);const f=new Map;f.set(t.getHash(),l+this.heuristic(t,s));const k=new E((p,I)=>(f.get(p.getHash())??1/0)-(f.get(I.getHash())??1/0));k.push(t);const A=new Map;for(;!k.empty();){let p=k.pop();if(s===p)return P.fromMapAndCosts(this,t,s,A);const I=p.getHash(),x=y.map(([n,o])=>this.surface.getTile(n+p.getX(),o+p.getY())),B=[];this.setCostAndMultiplier(0,B,r,x[0]),this.setCostAndMultiplier(1,B,r,x[1]),this.setCostAndMultiplier(2,B,r,x[2]),this.setCostAndMultiplier(3,B,r,x[3]),this.setDiagonalCostAndMultiplier(4,0,1,B,r,x[4]),this.setDiagonalCostAndMultiplier(5,0,2,B,r,x[5]),this.setDiagonalCostAndMultiplier(6,1,3,B,r,x[6]),this.setDiagonalCostAndMultiplier(7,2,3,B,r,x[7]),x.forEach((n,o)=>{if(!n)return;const c=B[o*2];if(!c||h.has(n))return;const a=n.getHash(),M=S.get(I)+B[o*2+1];if(M<(S.get(a)??1/0)){const w=g.get(I)+c;g.set(a,w),A.set(a,p),S.set(a,M),f.set(a,M+this.heuristic(n,s)),k.push(n),h.add(p)}})}}getHivePath(t,s){const i={},r=h=>(i[h.getHash()]??1)*(this.costMultipliers[h.getType()]??1);return t.reduce((h,d,l)=>{const g=this.getPath(d,s,r);return h.push(g),g&&t.length>l-1&&g.getTiles().forEach(S=>{S.hasStaticEntity()&&(i[S.getHash()]=.85),i[S.getHash()]=i[S.getHash()]+.1||1.1}),h},[])}getCost(t,s){const i=l=>this.costs[l.getType()]??null;if(!s)return i(t);const r=i(t),h=i(s);if(!r||!h)return null;const d=(r+h)/2;return!r||!h||t.getX()===s.getX()||t.getY()==s.getY()?d:d+(i(this.surface.getTile(t.getX(),s.getY()))+i(this.surface.getTile(s.getX(),t.getY())))/4}getSurface(){return this.surface}heuristic(t,s){return Math.abs(t.getX()-s.getX())+Math.abs(t.getY()-s.getY())}setCostAndMultiplier(t,s,i,r){if(!r)return;const h=this.costs[r.getType()];h&&(s[t*2]=h,s[t*2+1]=h*i(r))}setDiagonalCostAndMultiplier(t,s,i,r,h,d){if(!d||!r[s*2]||!r[i*2])return;const l=r[s*2+1]+r[i*2+1];if(l>tt)return;const g=this.costs[d.getType()];g&&(r[t*2]=g+(r[s*2]+r[i*2])/4,r[t*2+1]=g*h(d)+l/4)}}onmessage=({data:{width:e,height:t,buffer:s,costMultiplier:i,costs:r,startPoints:h,target:d}})=>{const l=new K({width:e,height:t,buffer:new Uint8Array(s)}),g=new et(l,i,r),S=h.map(({x:p,y:I})=>l.getTile(p,I)),f=l.getTile(d.x,d.y),A=g.getHivePath(S,f).filter(p=>!!p).map(p=>p.getTiles().map(I=>I.serialize()));postMessage(A)}})();
